import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Arrays;
import java.util.Random;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

public class GamePanel extends JPanel implements ActionListener,MouseMotionListener,MouseListener,Runnable {

	int[][] tile = new int[40][28];
	int row=0,col=0;
	int [][]temptile = new int [40][28];
	boolean loaded,eog=false ;
	JButton load;
	JFileChooser fileChooser;
	int returnValue;
	String path; 
	int mx, my;
	private static final long serialVersionUID = 1L;
	public GamePanel() {
		setLayout(null);
		load = new JButton();
		load.setSize(80, 30);
		load.setLocation(1000, 10);
		load.setText("Load");
		load.addActionListener(this);
		this.add(load);
		addMouseMotionListener(this);
		addMouseListener(this);
		setVisible(true);
		(new Thread(this)).start();
	}

	@Override
	public void paint(Graphics g) {
		super.paint(g);
		for (int i = 0; i < 18; i++) {
			for (int j = 0; j < 12; j++) {
				switch (tile[i + row][j + col]) {
				case 0:
					g.drawImage(Map.image[0][0].getImage(), (i * 50), (j * 50),
							null);
					break;
				case 1:
					g.drawImage(Map.image[1][0].getImage(), (i * 50), (j * 50),
							null);
					break;
				case 2: {
					g.drawImage(Map.image[0][0].getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(selectland(i+row,j+col).getImage(), (i * 50), (j * 50),
							null);
				}
					break;
				case 3: {
					g.drawImage(Map.image[0][0].getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(selectland(i+row,j+col).getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(Map.image[3][0].getImage(), (i * 50), (j * 50),
							null);
				}
					break;
				case 4: {
					g.drawImage(Map.image[0][0].getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(selectland(i+row,j+col).getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(Map.image[4][0].getImage(), (i * 50), (j * 50),
							null);
				}
					break;
				case 5: {
					g.drawImage(Map.image[0][0].getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(Map.image[5][0].getImage(), (i * 50), (j * 50),
							null);
				}
					break;
				case 6: {
					g.drawImage(Map.image[1][0].getImage(), (i * 50), (j * 50),
							null);
					g.drawImage(Map.image[6][0].getImage(), (i * 50), (j * 50),
							null);
				}
					break;
				}
			}
		}
		for (int i = 0; i < 40; i++) {
			for (int j = 0; j < 28; j++) {
				switch(tile[i][j]){
				case 0:{
					g.setColor(Color.BLUE);
					g.fillRect(920+((i)*6), 400+((j)*6), 6, 6);
				}
				break;
				case 1:{
					g.setColor(new Color(0,0,100));
					g.fillRect(920+(i*6), 400+(j*6), 6, 6);
				}
				break;
				case 2:{
					g.setColor(Color.GREEN);
					g.fillRect(920+(i*6), 400+(j*6), 6, 6);
				}
				break;
				case 3:{
					g.setColor(Color.GREEN);
					g.fillRect(920+(i*6), 400+(j*6), 6, 6);
					g.setColor(Color.gray);
					g.fillRect(920+(i*6)+1, 400+(j*6)+1, 4, 4);
				}
				break;
				case 4:{
					g.setColor(Color.GREEN);
					g.fillRect(920+(i*6), 400+(j*6), 6, 6);
					g.setColor(Color.BLACK);
					g.fillRect(920+(i*6)+1, 400+(j*6)+1, 4, 4);
				}
				break;
				case 5:{
					g.setColor(Color.blue);
					g.fillRect(920+(i*6), 400+(j*6), 6, 6);
					g.setColor(Color.ORANGE);
					g.fillRect(920+(i*6)+1, 400+(j*6)+1, 4, 4);
				}
				break;
				case 6:{
					g.setColor(new Color(0,0,100));
					g.fillRect(920+(i*6), 400+(j*6), 6, 6);
					g.setColor(Color.gray);
					g.fillRect(920+(i*6)+1, 400+(j*6)+1, 4, 4);
				}
				break;
				
				}
			}
		}
		g.setColor(Color.YELLOW);
		g.drawRect(920+(row*6), 400+(col*6), 108, 72);	
	//	g.drawImage(man.getPic().getImage(),man.getX(),man.getY(),null);
		int a1;
		if((a1=tile[setPier(2)[0]][(setPier(2)[1])+1])==0 || a1==1 || a1==5 || a1==6)
			g.drawImage(new ImageIcon("pics\\pier.png").getImage(),(setPier(2)[0])*50, (setPier(2)[1]+1)*50,null);
		else
			g.drawImage(new ImageIcon("pics\\pier.png").getImage(),(setPier(2)[0])*50, (setPier(2)[1]-col-1)*50,null);
		
		if((a1=tile[setPier(2)[2]][setPier(2)[3]+1])==0 || a1==1 || a1==5 || a1==6)
			g.drawImage(new ImageIcon("pics\\pier.png").getImage(), setPier(2)[2]*50, (setPier(2)[3]+1)*50,null);
		else
			g.drawImage(new ImageIcon("pics\\pier.png").getImage(), setPier(2)[2]*50, (setPier(2)[3]-1)*50,null);
	}

	@Override
	public void run() {
		while (!eog) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			scrollcheck();
			this.repaint();
		}		
	}
	
	private void scrollcheck() {
		if (mx > 850 && mx < 900 && row < 22){
			row++;
		}
		if (mx > 0 && mx < 20 && row > 0){
			row--;
		}
		if (my < 20 && my > 0 && mx>0 && mx<920 && col > 0)
			col--;
		if (my > 550 && my < 600 && mx>0 && mx<920 && col < 16)
			col++;
		}
	
public void load(String path) {
		
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(path);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			loaded = false;
		}
		ObjectInputStream ois = null;
		try {
			ois = new ObjectInputStream(fis);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			loaded = false;
		}
		try {
			temptile = (int[][]) ois.readObject();
			loaded = true;
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			loaded = false;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			loaded = false;
		}
		
		tile = temptile;
		setPier(2);
		this.repaint();
	}
	
	public ImageIcon selectland(int x, int y) {
		int n = 0;
		ImageIcon i=new ImageIcon("pics\\1.png");
		if(y==0)
			n+=0;
		else if ((tile[x][y - 1] == 2) || (tile[x][y - 1] == 3) || ((tile[x][y - 1] == 4)))
			n += 1;
		if(x==39)
			n+=0;
		else if ((tile[x + 1][y] == 2) || (tile[x + 1][y] == 3) || (tile[x + 1][y] == 4))
			n += 10;
		if(y==27)
			n+=0;
		else if ((tile[x][y + 1] == 2) || (tile[x ][y+1] == 3) || (tile[x ][y+1] == 4))
			n += 100;
		if(x==0)
			n+=0;
		else if ((tile[x - 1][y] == 2) || (tile[x - 1][y] == 3) || (tile[x - 1][y] == 4))
			n += 1000;
		switch (n) {
		case 0:
			i = new ImageIcon("pics\\1.png");
			break;
		case 111:
			i = new ImageIcon("pics\\2.png");
			break;
		case 1110:
			i = new ImageIcon("pics\\3.png");
			break;
		case 1101:
			i = new ImageIcon("pics\\4.png");
			break;
		case 1011:
			i = new ImageIcon("pics\\5.png");
			break;
		case 110:
			i = new ImageIcon("pics\\6.png");
			break;
		case 1100:
			i = new ImageIcon("pics\\7.png");
			break;
		case 1001:
			i = new ImageIcon("pics\\8.png");
			break;
		case 11:
			i = new ImageIcon("pics\\9.png");
			break;
		case 100:
			i = new ImageIcon("pics\\10.png");
			break;
		case 1000:
			i = new ImageIcon("pics\\11.png");
			break;
		case 1:
			i = new ImageIcon("pics\\12.png");
			break;
		case 10:
			i = new ImageIcon("pics\\13.png");
			break;
		case 1111:
			i = new ImageIcon("pics\\14.png");
			break;
		case 101:
			i = new ImageIcon("pics\\15.png");
			break;
		case 1010:
			i = new ImageIcon("pics\\16.png");
			break;
		}
		return i;
	}

	public boolean canBePier(int i,int j){
		int x,y,a;
		if((a=tile[i][j])==2 || a==3 || a==4){
			if(((x=tile[i][j-1])==0 || x==1 || x==5 || x==6) && ((y=tile[i+1][j])==0 || y==1 || y==5 || y==6))
				return true;
			if(((x=tile[i+1][j])==0 || x==1 || x==5 || x==6) && ((y=tile[i][j+1])==0 || y==1 || y==5 || y==6))
				return true;
			if(((x=tile[i][j+1])==0 || x==1 || x==5 || x==6) && ((y=tile[i-1][j])==0 || y==1 || y==5 || y==6))
				return true;
			if(((x=tile[i-1][j])==0 || x==1 || x==5 || x==6) && ((y=tile[i][j-1])==0 || y==1 || y==5 || y==6))
				return true;
		}
		return false;
	}
	
	public double distance(int i1,int j1,int i2,int j2){
		Random rand=new Random();
		double r = rand.nextDouble();
		double d=0;
		d=Math.pow((i2-i1),2)+Math.pow((j2-j1),2)+r;
		return d; 
	}
	
	public int[] setPier(int n){
		Vector <Integer>x=new Vector<Integer>(2,1);
		Vector <Integer>y=new Vector<Integer>(2,1);
		int counter=0;
		for(int i=1;i<39;i++){
			for(int j=1;j<27;j++){
				if(canBePier(i,j)){
					x.add(i);
					y.add(j);
					counter++;//the number of tile that can be pier
//					System.out.printf("%d , %d \n",i,j);
				}
			}
		}
		double [][] d=new double[counter][counter];//distance between every tow pierable tile(d[tile1][tile2])
		double []temp=new double[(counter)*(counter-1)/2];//distance between every tow pierable tile in a one demontional array to sort and get the max distance(combination 2 from counter equals (counter)*(counter-1)/2)
		for(int i=0;i<counter;i++){
			for(int j=0;j<counter;j++){
				d[i][j]=0;
			}
		}
		int c1=0;
		for(int i=0;i<counter;i++){
			for(int j=i+1;j<counter;j++){
				Random r=new Random();
			d[i][j]=distance(x.elementAt(i),y.elementAt(i),x.elementAt(j),y.elementAt(j))+r.nextDouble();
			temp[c1]=d[i][j];
			c1++;
			}
		}
		
		if(n==2){
			int a[]=new int[4];
//			double []sorted=new double[(counter)*(counter-1)/2];
			Arrays.sort(temp);
//			sorted=temp;
			for(int i=0;i<counter;i++){
				for(int j=i+1;j<counter;j++){
					if(d[i][j]==temp[((counter)*(counter-1)/2)-1]){
						a[0]=x.elementAt(i);
						a[1]=y.elementAt(i);
						a[2]=x.elementAt(j);
						a[3]=y.elementAt(j);
						System.out.println(a[0]);
						System.out.println(a[1]);
						System.out.println(a[2]);
						System.out.println(a[3]);
					}
				}
			}
			return a;
		}
		if(n==3){
			int a1[]=new int[6];
			return a1;
		}
		if(n==4){
			int a1[]=new int[8];
			return a1;
		}
		int a1[]=new int[4];
		return a1;
	}
	
	@Override
 	public void actionPerformed(ActionEvent e) {
		// TODO Auto-generated method stub
		if (e.getSource() == load){
			 fileChooser = new JFileChooser();
			 returnValue= fileChooser.showOpenDialog(null);
	        if (returnValue == JFileChooser.APPROVE_OPTION) {
	          File selectedFile = fileChooser.getSelectedFile();
	          path = selectedFile.getAbsolutePath();
	          load(path);
	        }
	        else
	        	loaded = false;
			if(loaded){
				JOptionPane.showMessageDialog(null,"Map loaded");
				return ;
			}
			else
				JOptionPane.showMessageDialog(null,"Map was not loaded!");
			return ;
		}
	}

	@Override
	public void mouseDragged(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		// TODO Auto-generated method stub
		mx = e.getX();
		my = e.getY();
	}

	@Override
	public void mouseClicked(MouseEvent arg0) {
		// TODO Auto-generated method stub
		if((mx>974) &&  (mx<1106) && (my>436) && (my<532)){
			row=((mx-974)/6);
			col=((my-436)/6);
		}else if(mx>920 && mx<964 && my>436 && my<532){
			col=((my-436)/6);
			row=0;
		}else if(mx>1106 && mx<1160  && my>436 && my<532) {
			col=((my-436)/6);
			row=22;
		}else if(my>400 && my<436 && mx>974 && mx<1106){
			row=((mx-974)/6);
			col=0;
		}else if(my>532 && my<568 && mx>974 && mx<1106){
			row=((mx-974)/6);
			col=16;
		}else if(mx>920 && mx<974 && my>400 && my<436){
			row=0;
			col=0;
		}else if(mx>920 && mx<974 && my>532 && my<568){
			row=0;
			col=16;
		}else if(mx>1106 && mx<1160 && my>400 && my<436){
			row=22;
			col=0;
		}else if(mx>1106 && mx<1160 && my>532 && my<568){
			row=22;
			col=16;
		}
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mousePressed(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	
}
